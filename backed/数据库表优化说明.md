# 时光轨迹表优化说明

## 📋 优化内容

### km_timeline_event 表优化

#### 1. 移除冗余字段
- ❌ 删除 `topic_name` 字段（冗余数据）
  - **原因**：主题名称已存储在 `km_topic` 表中
  - **方案**：通过 `topic_id` 外键关联获取主题名称

#### 2. 添加外键约束
- ✅ 新增外键 `fk_timeline_topic`
  - 关联：`km_timeline_event.topic_id` → `km_topic.id`
  - 级联删除：`ON DELETE CASCADE`
  - **好处**：删除主题时自动删除相关里程碑

#### 3. 统一标准字段
- ✅ `rec_creator` VARCHAR(50) → VARCHAR(64)
- ✅ `rec_revisor` VARCHAR(50) → VARCHAR(64)
- ✅ `arch_flag` CHAR(1) → INT(1)
- **好处**：与其他表保持一致

## 🔄 数据库迁移

### 方式一：重建表（推荐用于开发环境）

```sql
-- 1. 备份数据
CREATE TABLE km_timeline_event_backup AS SELECT * FROM km_timeline_event;

-- 2. 删除旧表
DROP TABLE IF EXISTS km_timeline_event;

-- 3. 执行新建表脚本
SOURCE backed/src/main/resources/db/km_topic.sql;
SOURCE backed/src/main/resources/db/km_timeline_event.sql;

-- 4. 恢复数据（不包含 topic_name）
INSERT INTO km_timeline_event (
  id, event_type, title, description, event_date, topic_id,
  rec_creator, rec_create_time, rec_revisor, rec_revise_time, arch_flag
)
SELECT 
  id, event_type, title, description, event_date, topic_id,
  rec_creator, rec_create_time, rec_revisor, rec_revise_time, 
  CAST(arch_flag AS UNSIGNED) as arch_flag
FROM km_timeline_event_backup;
```

### 方式二：ALTER TABLE（用于生产环境）

```sql
-- 1. 删除 topic_name 字段
ALTER TABLE km_timeline_event DROP COLUMN topic_name;

-- 2. 修改字段类型
ALTER TABLE km_timeline_event 
  MODIFY COLUMN rec_creator VARCHAR(64) NOT NULL DEFAULT 'system',
  MODIFY COLUMN rec_revisor VARCHAR(64) NOT NULL DEFAULT 'system',
  MODIFY COLUMN arch_flag INT(1) NOT NULL DEFAULT 1;

-- 3. 添加外键（确保 km_topic 表已存在）
ALTER TABLE km_timeline_event 
  ADD CONSTRAINT fk_timeline_topic 
  FOREIGN KEY (topic_id) REFERENCES km_topic(id) ON DELETE CASCADE;

-- 4. 验证
DESC km_timeline_event;
SHOW CREATE TABLE km_timeline_event;
```

## 📝 代码修改清单

### 后端修改
- [x] `TimelineEvent.java` - 移除 topicName 属性
- [x] `TimelineEventMapper.xml` - 移除 topic_name 映射
- [x] `TimelineEventController.java` - 移除 topicName 参数处理
- [x] `TimelineEventService.java` - 从 km_topic 表JOIN获取主题名称

### 前端修改
- [x] `DailySummary.vue` - 移除 topicName 参数传递

### 数据库修改
- [x] `km_timeline_event.sql` - 更新表结构

## ✅ 优化后的表结构

### km_timeline_event

```sql
CREATE TABLE `km_timeline_event` (
  `id` BIGINT NOT NULL AUTO_INCREMENT COMMENT '主键ID',
  `event_type` VARCHAR(20) NOT NULL COMMENT '事件类型',
  `title` VARCHAR(200) NOT NULL COMMENT '事件标题',
  `description` TEXT COMMENT '事件描述',
  `event_date` DATE NOT NULL COMMENT '事件日期',
  `topic_id` VARCHAR(50) COMMENT '主题ID（关联km_topic表）',
  
  -- 标准字段
  `rec_creator` VARCHAR(64) NOT NULL DEFAULT 'system',
  `rec_create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `rec_revisor` VARCHAR(64) NOT NULL DEFAULT 'system',
  `rec_revise_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `arch_flag` INT(1) NOT NULL DEFAULT '1',
  
  PRIMARY KEY (`id`),
  KEY `idx_event_type` (`event_type`),
  KEY `idx_event_date` (`event_date`),
  KEY `idx_topic_id` (`topic_id`),
  CONSTRAINT `fk_timeline_topic` FOREIGN KEY (`topic_id`) REFERENCES `km_topic` (`id`) ON DELETE CASCADE
) ENGINE=InnoDB;
```

**字段数量**：11个（减少1个）

### km_topic

```sql
CREATE TABLE `km_topic` (
  `id` VARCHAR(50) NOT NULL COMMENT '主题ID',
  `name` VARCHAR(100) NOT NULL COMMENT '主题名称',
  `rec_creator` VARCHAR(64) NOT NULL DEFAULT 'system',
  `rec_create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP,
  `rec_revisor` VARCHAR(64) NOT NULL DEFAULT 'system',
  `rec_revise_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
  `arch_flag` INT(1) NOT NULL DEFAULT '1',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB;
```

**字段数量**：7个

## 🎯 优化效果

### 数据一致性
- ✅ 主题名称单一数据源（km_topic表）
- ✅ 修改主题名称自动同步到所有里程碑
- ✅ 外键约束保证数据完整性

### 性能优化
- ✅ 减少存储空间（移除冗余字段）
- ✅ 减少更新操作（不需同步更新topic_name）
- ⚡ JOIN 查询性能良好（有索引支持）

### 维护性
- ✅ 表结构更清晰
- ✅ 数据关系更规范
- ✅ 级联删除自动维护数据一致性

## 🔍 查询主题名称示例

### 后端 Service 层
```java
// 获取里程碑时 JOIN km_topic 表
public Map<String, Object> getMilestonesGroupByTopic() {
    // 从 km_topic 表获取所有主题
    List<Topic> allTopics = topicMapper.selectAll();
    
    // 从 km_timeline_event 表获取所有里程碑
    List<TimelineEvent> milestones = timelineEventMapper.selectMilestones();
    
    // 按 topic_id 分组后，使用主题表的 name 字段
    for (Topic topicEntity : allTopics) {
        topic.put("name", topicEntity.getName()); // 从主题表获取
    }
}
```

### SQL 查询示例
```sql
-- 查询里程碑及其主题名称
SELECT 
    e.id,
    e.title,
    e.description,
    e.event_date,
    e.topic_id,
    t.name as topic_name  -- 从 km_topic 表获取
FROM km_timeline_event e
LEFT JOIN km_topic t ON e.topic_id = t.id
WHERE e.event_type = 'milestone' AND e.arch_flag = 1;
```

## ⚠️ 注意事项

1. **执行顺序**：必须先创建 `km_topic` 表，再创建 `km_timeline_event` 表（外键依赖）
2. **数据迁移**：迁移数据时确保所有 `topic_id` 在 `km_topic` 表中存在
3. **级联删除**：删除主题会自动删除其所有里程碑，操作前需确认
4. **已有数据**：如有生产数据，建议先备份再执行 ALTER TABLE

## 📅 变更记录

- **日期**：2025-10-08
- **版本**：v1.7.0
- **类型**：表结构优化
- **影响**：km_timeline_event 表

