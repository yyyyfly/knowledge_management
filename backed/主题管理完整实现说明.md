# 主题管理完整实现说明

## 功能概述

实现了独立的主题管理功能，点击"确认"按钮后主题数据会立即保存到数据库，解决了之前只在前端临时保存的问题。

## 数据库设计

### 新建主题表：`km_topic`

```sql
CREATE TABLE `km_topic` (
  `id` VARCHAR(50) NOT NULL COMMENT '主题ID',
  `name` VARCHAR(100) NOT NULL COMMENT '主题名称',
  `rec_creator` VARCHAR(64) NOT NULL DEFAULT 'system' COMMENT '创建人',
  `rec_create_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
  `rec_revisor` VARCHAR(64) NOT NULL DEFAULT 'system' COMMENT '修改人',
  `rec_revise_time` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '修改时间',
  `arch_flag` INT(1) NOT NULL DEFAULT '1' COMMENT '归档标志:0-已删除,1-正常',
  PRIMARY KEY (`id`),
  KEY `idx_arch_flag` (`arch_flag`),
  KEY `idx_create_time` (`rec_create_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COLLATE=utf8mb4_unicode_ci COMMENT='时间轴主题表';
```

**设计说明**：
- 独立的主题表，与里程碑事件分离
- 使用 `VARCHAR(50)` 作为主题ID（支持用户自定义ID如 `user-topic-{timestamp}`）
- 只保留主题名称，简化设计（描述字段已移除，如需扩展可建关联表）
- 标准的iPlatv6框架审计字段
- 逻辑删除设计（`arch_flag`）

## 后端实现

### 1. 实体类：`Topic.java`
```java
@Data
@EqualsAndHashCode(callSuper = true)
public class Topic extends BaseEntity {
    private String id;        // 主题ID
    private String name;      // 主题名称
}
```

### 2. Mapper接口：`TopicMapper.java`
- `insert(Topic topic)` - 插入主题
- `selectById(String id)` - 根据ID查询
- `selectAll()` - 查询所有主题
- `deleteById(String id, String revisor)` - 删除主题（逻辑删除）
- `update(Topic topic)` - 更新主题

### 3. Service层：`TopicService.java`
- `create(Topic topic, String creator)` - 创建主题
- `getById(String id)` - 获取主题
- `getAll()` - 获取所有主题
- `delete(String id, String revisor)` - 删除主题
- `update(Topic topic, String revisor)` - 更新主题

### 4. Controller层：`TimelineEventController.java`

#### 新增接口

##### (1) 创建主题
- **URL**: `POST /timeline/topic`
- **请求体**:
```json
{
  "id": "user-topic-1696824000000",
  "name": "Spring Boot学习历程"
}
```
- **返回**:
```json
{
  "code": 200,
  "message": "创建成功",
  "data": {
    "id": "user-topic-1696824000000",
    "name": "Spring Boot学习历程"
  }
}
```

##### (2) 获取所有主题
- **URL**: `GET /timeline/topics`
- **返回**:
```json
{
  "code": 200,
  "data": [
    {
      "id": "km-system",
      "name": "知识管理系统"
    },
    {
      "id": "user-topic-1696824000000",
      "name": "Spring Boot学习历程"
    }
  ]
}
```

##### (3) 删除主题（增强）
- **URL**: `DELETE /timeline/topic/{topicId}`
- **功能**: 级联删除主题及其所有里程碑
- **逻辑**:
  1. 先删除主题下的所有里程碑（`arch_flag = 0`）
  2. 再删除主题本身（`arch_flag = 0`）

### 5. Service优化：`TimelineEventService.java`

#### `getMilestonesGroupByTopic()` 方法优化
```java
public Map<String, Object> getMilestonesGroupByTopic() {
    // 1. 获取所有主题（从主题表）
    List<Topic> allTopics = topicMapper.selectAll();
    
    // 2. 获取所有里程碑
    List<TimelineEvent> milestones = timelineEventMapper.selectMilestones();
    
    // 3. 按主题分组里程碑
    Map<String, List<TimelineEvent>> groupedMap = milestones.stream()
        .collect(Collectors.groupingBy(...));
    
    // 4. 遍历所有主题（包括没有里程碑的主题）
    for (Topic topicEntity : allTopics) {
        // ... 组装数据
    }
    
    return result;
}
```

**优化点**：
- 从主题表读取主题信息（而非从里程碑中提取）
- 支持显示没有里程碑的空主题
- 主题名称更新后自动同步

## 前端实现

### 1. DailySummary.vue 修改

#### (1) 新建主题确认功能
```typescript
const confirmNewTopic = async () => {
  if (!milestoneForm.value.newTopicName.trim()) {
    alert('请输入主题名称')
    return
  }
  
  const newTopicId = `user-topic-${Date.now()}`
  const newTopicName = milestoneForm.value.newTopicName.trim()
  
  try {
    // 调用API保存主题到数据库
    const response = await request.post('/timeline/topic', {
      id: newTopicId,
      name: newTopicName
    })
    
    if (response.code === 200) {
      // 添加到可用主题列表
      availableTopics.value.push({
        id: newTopicId,
        name: newTopicName
      })
      
      // 自动选中新建的主题
      milestoneForm.value.topicId = newTopicId
      
      // 清空输入框并关闭
      milestoneForm.value.newTopicName = ''
      showNewTopicInput.value = false
      
      alert('✅ 新主题已创建并保存到数据库')
    }
  } catch (error) {
    console.error('创建主题失败:', error)
    alert('创建失败，请稍后重试')
  }
}
```

#### (2) 加载主题列表优化
```typescript
const loadAvailableTopics = async () => {
  try {
    const response = await request.get('/timeline/topics')
    
    if (response.code === 200) {
      availableTopics.value = (response.data || []).map((topic: any) => ({
        id: topic.id,
        name: topic.name
      }))
    }
  } catch (error) {
    console.error('加载主题列表失败:', error)
    availableTopics.value = []
  }
}
```

**改进点**：
- 从 `/timeline/topics` 获取主题列表（而非从 `/timeline/milestones` 提取）
- 直接返回主题数据，无需二次处理

## 数据流程

### 创建主题流程
```
用户输入主题名称
   ↓
点击"确认"按钮
   ↓
confirmNewTopic() 函数
   ↓
生成唯一ID: user-topic-{timestamp}
   ↓
POST /timeline/topic 保存到数据库
   ↓
添加到前端 availableTopics 列表
   ↓
自动选中该主题
   ↓
提示用户创建成功
```

### 加载主题流程
```
页面加载/激活
   ↓
loadAvailableTopics() 函数
   ↓
GET /timeline/topics 获取所有主题
   ↓
更新 availableTopics 列表
   ↓
下拉框显示最新主题列表
```

### 删除主题流程
```
用户选择主题并点击删除
   ↓
deleteTopic() 函数
   ↓
二次确认
   ↓
DELETE /timeline/topic/{topicId}
   ↓
后端：删除所有里程碑（arch_flag = 0）
   ↓
后端：删除主题（arch_flag = 0）
   ↓
前端：从列表移除该主题
   ↓
刷新主题列表
```

## 部署步骤

### 1. 数据库部署

#### 方式一：直接执行SQL文件
```bash
# 在MySQL中执行
mysql -u root -p knowledge_management < backed/src/main/resources/db/km_topic.sql
```

#### 方式二：手动创建
```sql
-- 1. 创建主题表
CREATE TABLE `km_topic` (...);

-- 2. 插入示例数据
INSERT INTO `km_topic` (...) VALUES (...);
```

### 2. 后端部署

#### 检查新增文件
```
backed/src/main/java/com/knowledge/
├── entity/Topic.java                    ✅ 新增
├── mapper/TopicMapper.java              ✅ 新增
├── service/TopicService.java            ✅ 新增
└── controller/TimelineEventController.java  ✅ 修改

backed/src/main/resources/
├── db/km_topic.sql                      ✅ 新增
└── mapper/TopicMapper.xml               ✅ 新增
```

#### 编译并启动
```bash
cd backed
mvn clean compile
mvn package
java -jar target/knowledge-management-system-1.0.0.jar
```

### 3. 前端部署

#### 修改文件
- `fronted/src/views/daily/DailySummary.vue` ✅ 已修改

#### 重启开发服务器
```bash
cd fronted
npm run dev
```

或构建生产版本：
```bash
npm run build
```

## 测试验证

### 测试步骤

#### 1. 新建主题测试
1. 访问 `http://localhost:5173/daily/daily-summary`
2. 切换到"历史事件记录" > "专项时间轴里程碑"
3. 点击"新建主题"按钮
4. 输入主题名称（如"Redis学习路线"）
5. 点击"确认"按钮
6. 验证提示："✅ 新主题已创建并保存到数据库"
7. 验证下拉框自动选中新主题
8. 刷新页面，验证主题仍然存在

#### 2. 主题持久化测试
1. 新建主题后记下主题ID
2. 查询数据库：
```sql
SELECT * FROM km_topic WHERE id = 'user-topic-{timestamp}';
```
3. 验证数据已保存
4. 验证 `arch_flag = 1`（正常状态）

#### 3. 删除主题测试
1. 选择一个主题
2. 点击删除按钮
3. 确认删除
4. 验证主题从下拉框消失
5. 查询数据库：
```sql
SELECT * FROM km_topic WHERE id = '{topicId}';
SELECT * FROM km_timeline_event WHERE topic_id = '{topicId}';
```
6. 验证主题和里程碑的 `arch_flag = 0`（已删除）

#### 4. 空主题显示测试
1. 创建新主题但不添加里程碑
2. 访问 `http://localhost:5173/overview/timeline`
3. 切换到"专项时间轴"
4. 验证新主题显示在列表中（timeline为空）

## API文档总结

| 接口 | 方法 | URL | 说明 |
|------|------|-----|------|
| 创建主题 | POST | `/timeline/topic` | 立即保存主题到数据库 |
| 获取所有主题 | GET | `/timeline/topics` | 获取主题列表 |
| 删除主题 | DELETE | `/timeline/topic/{topicId}` | 级联删除主题及里程碑 |
| 获取里程碑 | GET | `/timeline/milestones` | 优化为从主题表读取 |

## 注意事项

1. **主题ID生成**：使用时间戳生成唯一ID（`user-topic-${Date.now()}`）
2. **逻辑删除**：主题和里程碑都使用逻辑删除（`arch_flag = 0`）
3. **级联删除**：删除主题时自动删除所有关联的里程碑
4. **空主题支持**：允许创建没有里程碑的主题
5. **数据同步**：主题名称更新会自动同步到时间轴显示

## 问题修复

### 修复前的问题
- ❌ 点击"确认"只在前端临时保存主题
- ❌ 刷新页面主题消失
- ❌ 主题数据未持久化到数据库

### 修复后的效果
- ✅ 点击"确认"立即保存到数据库
- ✅ 刷新页面主题依然存在
- ✅ 主题数据完全持久化
- ✅ 支持独立的主题管理

## 版本记录

- **版本**: v1.7.0
- **日期**: 2025-10-08
- **变更类型**: 功能增强
- **影响范围**: 主题管理、时间轴

